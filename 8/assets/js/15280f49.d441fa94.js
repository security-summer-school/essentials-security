"use strict";(self.webpackChunkessentials_security=self.webpackChunkessentials_security||[]).push([[320],{5680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>p});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),y=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=y(e.components);return a.createElement(o.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=y(t),m=i,p=c["".concat(o,".").concat(m)]||c[m]||d[m]||r;return t?a.createElement(p,s(s({ref:n},u),{},{components:t})):a.createElement(p,s({ref:n},u))}));function p(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,s=new Array(r);s[0]=m;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[c]="string"==typeof e?e:i,s[1]=l;for(var y=2;y<r;y++)s[y]=t[y];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9660:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>y});var a=t(8168),i=(t(6540),t(5680));const r={linkTitle:"09. Binary Analysis",type:"docs",weight:10},s="Binary Analysis",l={unversionedId:"Binary Introduction/Binary Analysis/README",id:"Binary Introduction/Binary Analysis/README",title:"Binary Analysis",description:"Reminders",source:"@site/docs/Binary Introduction/Binary Analysis/README.md",sourceDirName:"Binary Introduction/Binary Analysis",slug:"/Binary Introduction/Binary Analysis/",permalink:"/essentials-security/8/Binary Introduction/Binary Analysis/",draft:!1,tags:[],version:"current",frontMatter:{linkTitle:"09. Binary Analysis",type:"docs",weight:10},sidebar:"sidebar",previous:{title:"Binary Analysis",permalink:"/essentials-security/8/Binary Introduction/Binary Analysis/"},next:{title:"Drills",permalink:"/essentials-security/8/Binary Introduction/Binary Analysis/Drills/"}},o={},y=[{value:"Reminders",id:"reminders",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Static Analysis",id:"static-analysis",level:2},{value:"strings",id:"strings",level:3},{value:"file",id:"file",level:3},{value:"Counter-measures",id:"counter-measures",level:4},{value:"nm",id:"nm",level:3},{value:"Counter-measures: Strip",id:"counter-measures-strip",level:4},{value:"objdump",id:"objdump",level:3},{value:"Counter-measures",id:"counter-measures-1",level:4},{value:"Ghidra",id:"ghidra",level:3},{value:"Counter-measures",id:"counter-measures-2",level:4},{value:"Dynamic Analysis",id:"dynamic-analysis",level:2},{value:"strace",id:"strace",level:3},{value:"ltrace",id:"ltrace",level:3},{value:"gdb",id:"gdb",level:3},{value:"Summary",id:"summary",level:2}],u={toc:y},c="wrapper";function d(e){let{components:n,...t}=e;return(0,i.yg)(c,(0,a.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"binary-analysis"},"Binary Analysis"),(0,i.yg)("h2",{id:"reminders"},"Reminders"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"code can't just be run;\nit needs to be compiled and linked, becoming an executable"),(0,i.yg)("li",{parentName:"ul"},"the value of most symbols is placed in the binary file, in sections, and can be observed without actually running the executable")),(0,i.yg)("h2",{id:"introduction"},"Introduction"),(0,i.yg)("p",null,"Today's session aims to give you some tools to analyze a binary, in order to determine what that binary does and if it can hurt your system."),(0,i.yg)("h2",{id:"static-analysis"},"Static Analysis"),(0,i.yg)("p",null,"Static analysis implies investigating the binary without running it.\nThis means looking into the effective binary file for strings, symbols, interesting addresses and so on."),(0,i.yg)("h3",{id:"strings"},"strings"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"strings")," is used to find strings in a binary file - very intuitive.\nIt is the most basic static analysis tool available.\nBefore any other more complex analysis takes place, a ",(0,i.yg)("inlineCode",{parentName:"p"},"strings")," can find many hidden secrets."),(0,i.yg)("h3",{id:"file"},"file"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"file")," is another useful tool, not only for binary analysis.\nIt should be used before any investigation, to make sure that the binary is a binary file, and not an archive.\nIt also shows if the executable is statically-linked (lots of strings, functions) or dynamically-linked."),(0,i.yg)("h4",{id:"counter-measures"},"Counter-measures"),(0,i.yg)("p",null,"For ",(0,i.yg)("inlineCode",{parentName:"p"},"file")," there is no counter-measure to hide the data that would be found by it.\nFor ",(0,i.yg)("inlineCode",{parentName:"p"},"strings"),", one way to counter it is to encrypt / obfuscate important data.\nBut keep in mind that the codified content will be visible, and can be deciphered.\nThat's why they are, almost always, used first when analysing a binary."),(0,i.yg)("h3",{id:"nm"},"nm"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"nm")," is used to find ",(0,i.yg)("strong",{parentName:"p"},"symbols")," - variable names, function names, and their addresses.\nIt also shows where these symbols are placed: text (T or t), rodata (R or r), bss (B or b), etc.\n",(0,i.yg)("a",{parentName:"p",href:"https://www.thegeekstuff.com/2012/03/linux-nm-command/"},"Here")," you can find all the symbols' meaning."),(0,i.yg)("p",null,"The difference between capital-letter symbols and lowercase symbols is the following:\nCapital-letter symbols are global, meaning they can be referenced from other object files.\nExample: ",(0,i.yg)("inlineCode",{parentName:"p"},"object1.o")," has a global symbol named ",(0,i.yg)("inlineCode",{parentName:"p"},"global_var"),".\n",(0,i.yg)("inlineCode",{parentName:"p"},"object2.o")," can use ",(0,i.yg)("inlineCode",{parentName:"p"},"global_var"),", if ",(0,i.yg)("inlineCode",{parentName:"p"},"object1.o")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"object2.o")," are linked together."),(0,i.yg)("h4",{id:"counter-measures-strip"},"Counter-measures: Strip"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"strip")," removes all symbols from a binary file.\nIf a binary is stripped, ",(0,i.yg)("inlineCode",{parentName:"p"},"nm")," becomes useless."),(0,i.yg)("h3",{id:"objdump"},"objdump"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," is a disassembler.\nIt takes binary files and transforms them to hexadecimal values and, where possible, assembly language.\nIt is useful in many cases: when we want to explore the sections of a program, when we want to see what a specific function does, or when we want to make sure that the binary won't crash more complex analysis tools (!).\n",(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," is a fast way to turn a binary file into more accessible format."),(0,i.yg)("h4",{id:"counter-measures-1"},"Counter-measures"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," is pretty good at what it must do.\nIt becomes less helpful if the binary is large, with multiple functions that call each other and we have a hard time understanding the flow of the application.\nThat's why it is a bad idea, generally, to break down real-life applications with ",(0,i.yg)("inlineCode",{parentName:"p"},"objdump"),"."),(0,i.yg)("h3",{id:"ghidra"},"Ghidra"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"Ghidra")," is a decompiler: it turns a binary file back into C code.\nIt also does function analysis, meaning it constructs a tree of function calls.\nIt is the best tool to understand what a binary does, without running it."),(0,i.yg)("h4",{id:"counter-measures-2"},"Counter-measures"),(0,i.yg)("p",null,"Unorthodox code, self-changing code, polymorphic code and other measures were taken by various people to counter Ghidra.\n",(0,i.yg)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=HlUe0TUHOIc&ab_channel=DEFCONConference"},"This talk")," by Christopher Domas is one of the best examples of measures taken to counter Ghidra and other decompilers."),(0,i.yg)("h2",{id:"dynamic-analysis"},"Dynamic Analysis"),(0,i.yg)("p",null,"Dynamic analysis means observing the behaviour of the binary, while it is running.\nThis is performed by tracing or sandboxing."),(0,i.yg)("p",null,"Tracing is the process during which various checkpoints are placed in the code, that send alerts when the execution has reached them.\nGenerally, the context (registers, stack, variables) is also displayed."),(0,i.yg)("p",null,"Sandboxing is a more complex process, in which you isolate a binary in a virtual machine (usually), run it and observe the changes made on the system: modified files, network traffic, etc."),(0,i.yg)("p",null,"Today, we are going to explore tracing."),(0,i.yg)("h3",{id:"strace"},"strace"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"strace")," shows system calls performed by a binary application.\nThat means opening any kind of file, reading and writing into files, ",(0,i.yg)("inlineCode",{parentName:"p"},"mprotect"),"s and other things.\nIt is useful to find out if the program does any changes to the system itself, or if it writes in some files."),(0,i.yg)("h3",{id:"ltrace"},"ltrace"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"ltrace")," shows calls to dynamic library functions, along with system calls.\nIt is similar to ",(0,i.yg)("inlineCode",{parentName:"p"},"strace"),"."),(0,i.yg)("h3",{id:"gdb"},"gdb"),(0,i.yg)("p",null,"GDB is the most powerful dynamic analysis tool available to the regular user.\nIt allows executing the code instruction by instruction, inspecting memory areas, changing memory areas, jumping to other pieces of code, that weren't executed normally.\nGDB is best used when the user has knowledge about assembly language, which will be presented in the last 2 sessions.\nFor this session, GDB isn't required."),(0,i.yg)("h2",{id:"summary"},"Summary"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Static analysis is the investigation of a binary file without actually running it.\nIt means disassembling, decompiling the executable, or directly reading the actual contents of the executable."),(0,i.yg)("li",{parentName:"ul"},"Static analysis is performed with tools like ",(0,i.yg)("inlineCode",{parentName:"li"},"strings"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"file"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"nm"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"Ghidra"),"."),(0,i.yg)("li",{parentName:"ul"},"Dynamic analysis the investigation of an executable while it is running"),(0,i.yg)("li",{parentName:"ul"},"Dynamic analysis is performed using tools like ",(0,i.yg)("inlineCode",{parentName:"li"},"strace"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"ltrace"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"gdb"),".")))}d.isMDXComponent=!0}}]);