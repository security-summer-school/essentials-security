"use strict";(self.webpackChunkessentials_security=self.webpackChunkessentials_security||[]).push([[6387],{5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>c});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),d=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=d(e.components);return a.createElement(o.Provider,{value:n},e.children)},g="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},y=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),g=d(t),y=i,c=g["".concat(o,".").concat(y)]||g[y]||m[y]||r;return t?a.createElement(c,s(s({ref:n},p),{},{components:t})):a.createElement(c,s({ref:n},p))}));function c(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,s=new Array(r);s[0]=y;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[g]="string"==typeof e?e:i,s[1]=l;for(var d=2;d<r;d++)s[d]=t[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}y.displayName="MDXCreateElement"},8881:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=t(8168),i=(t(6540),t(5680));const r={linkTitle:"10. Assembly Language",type:"docs",weight:10},s="Assembly Language",l={unversionedId:"Binary Introduction/Assembly Language/README",id:"Binary Introduction/Assembly Language/README",title:"Assembly Language",description:"Introduction",source:"@site/docs/Binary Introduction/Assembly Language/README.md",sourceDirName:"Binary Introduction/Assembly Language",slug:"/Binary Introduction/Assembly Language/",permalink:"/essentials-security/5/Binary Introduction/Assembly Language/",draft:!1,tags:[],version:"current",frontMatter:{linkTitle:"10. Assembly Language",type:"docs",weight:10},sidebar:"sidebar",previous:{title:"Assembly Language",permalink:"/essentials-security/5/Binary Introduction/Assembly Language/"},next:{title:"Taming the Stack",permalink:"/essentials-security/5/Binary Introduction/Taming the Stack/"}},o={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Reminders and Prerequisites",id:"reminders-and-prerequisites",level:2},{value:"Assembly",id:"assembly",level:2},{value:"Registers",id:"registers",level:2},{value:"Registers in an X64 CPU",id:"registers-in-an-x64-cpu",level:3},{value:"<code>rip</code>",id:"rip",level:4},{value:"General Purpose Registers",id:"general-purpose-registers",level:4},{value:"Smaller Registers",id:"smaller-registers",level:4},{value:"Assembly Instructions",id:"assembly-instructions",level:2},{value:"<code>mov</code>",id:"mov",level:3},{value:"Data Manipulation",id:"data-manipulation",level:3},{value:"Control Flow",id:"control-flow",level:3},{value:"<code>jmp</code>",id:"jmp",level:4},{value:"<code>eflags</code>",id:"eflags",level:4},{value:"Conditional jumps",id:"conditional-jumps",level:4},{value:"<code>cmp</code> and <code>test</code>",id:"cmp-and-test",level:5},{value:"Loops",id:"loops",level:4},{value:"Dereferencing Addresses",id:"dereferencing-addresses",level:2},{value:"Endianness",id:"endianness",level:3},{value:"Reading Assembly",id:"reading-assembly",level:2},{value:"<code>objdump</code>",id:"objdump",level:3},{value:"GDB",id:"gdb",level:3},{value:"Summary",id:"summary",level:2},{value:"Activities",id:"activities",level:2},{value:"In Plain Assembly",id:"in-plain-assembly",level:3},{value:"Gotta Link Em All",id:"gotta-link-em-all",level:3},{value:"Jump Maze",id:"jump-maze",level:3},{value:"Crypto",id:"crypto",level:3},{value:"Call Me Little Sunshine",id:"call-me-little-sunshine",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"The Whole ISA",id:"the-whole-isa",level:3},{value:"Caches",id:"caches",level:3},{value:"Assembly Syntaxes",id:"assembly-syntaxes",level:3},{value:"<code>lea</code>",id:"lea",level:3}],p={toc:d},g="wrapper";function m(e){let{components:n,...r}=e;return(0,i.yg)(g,(0,a.A)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"assembly-language"},"Assembly Language"),(0,i.yg)("h2",{id:"introduction"},"Introduction"),(0,i.yg)("p",null,"In the previous 2 sessions you started discovering what binary security looks like.\n",(0,i.yg)("a",{parentName:"p",href:"../binary-analysis/"},"Last session")," you learnt two very powerful means of investigating and even reverse engineering executables: static and dynamic analysis.\nIn order to leverage them efficiently, you used Ghidra for static analysis.\nNow we'll introduce GDB for dynamic analysis.\nYou've most likely noticed that they are able to display the source code of the application.\nGDB can do so when said app was compiled with ",(0,i.yg)("em",{parentName:"p"},"debug symbols"),", while Ghidra does not even need debug symbols.\nIt infers the original C code from its compiled representation (learn more about how Ghidra does this by taking part in the ",(0,i.yg)("a",{parentName:"p",href:"https://security-summer-school.github.io/binary/static-analysis/#ida-and-ghidra"},"Binary Security track")," next year).\nThis representation is called ",(0,i.yg)("strong",{parentName:"p"},"assembly language"),".\nBoth Ghidra and GDB can display the program's code in assembly language.\nToday we will demystify this low-level language and learn to understand it."),(0,i.yg)("h2",{id:"reminders-and-prerequisites"},"Reminders and Prerequisites"),(0,i.yg)("p",null,"For this session, you need:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"a working knowledge of the C programming language and familiarity with pointers"),(0,i.yg)("li",{parentName:"ul"},"basic skills with Ghidra and GDB"),(0,i.yg)("li",{parentName:"ul"},"understand how an executable file is created, as described in the ",(0,i.yg)("a",{parentName:"li",href:"../application-lifetime/"},"Application Lifetime session")),(0,i.yg)("li",{parentName:"ul"},"knowledge of the following means of representing data: ASCII, binary, hexadecimal.")),(0,i.yg)("p",null,"Check out the session on ",(0,i.yg)("a",{parentName:"p",href:"../data-representation/"},"Data Representation")," for a reminder."),(0,i.yg)("h2",{id:"assembly"},"Assembly"),(0,i.yg)("p",null,"Assembly is a low-level language used as a human-readable representation of instructions executed by the CPU.\nThere is a one-to-one mapping between the binary code executed by the CPU and Assembly.\nFew people write Assembly, but many people are required to read it:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"security engineers"),(0,i.yg)("li",{parentName:"ul"},"compiler / interpreter developers"),(0,i.yg)("li",{parentName:"ul"},"embedded developers"),(0,i.yg)("li",{parentName:"ul"},"operating systems developers")),(0,i.yg)("p",null,"Simply put, if a field is close to CPU it requires (some knowledge of) Assembly.\nSo let's learn this language!"),(0,i.yg)("h2",{id:"registers"},"Registers"),(0,i.yg)("p",null,'You might have already seen the image below.\nIt shows the various places where data can be kept.\nNote that this data can be both non-persistent and persistent.\nNon-persistent data is gone once you shut down the computer.\nIt\'s kept in all levels from "Main Memory" upwards.\nThe "Main Memory" is simply referred to as ',(0,i.yg)("strong",{parentName:"p"},"memory")," or RAM."),(0,i.yg)("p",null,"Persistent storage refers to data on ",(0,i.yg)("strong",{parentName:"p"},"disks"),": HDD, SSD, CDs, DVDs, magnetic tapes, even in the cloud (where cloud storage providers also use HDDs, SSDs etc.).\nIf you shut down your laptop or your mobile phone, your pictures or video games remain unchanged.\nThis is because they are stored ",(0,i.yg)("em",{parentName:"p"},"on your device's disk"),".\nWe simply refer to persistent storage as ",(0,i.yg)("strong",{parentName:"p"},"storage"),".\nTake note of the difference between ",(0,i.yg)("em",{parentName:"p"},"storage")," and ",(0,i.yg)("em",{parentName:"p"},"memory"),"."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Memory Hierarchy",src:t(6486).A,width:"1567",height:"1010"})),(0,i.yg)("p",null,"In most programming languages you can freely access data everywhere up to and including the memory.\nIn assembly however, you also have access to the ",(0,i.yg)("strong",{parentName:"p"},"registers")," and can influence the ",(0,i.yg)("strong",{parentName:"p"},"cache"),".\nWe won't be dealing with the cache in this session, but you can read more about them ",(0,i.yg)("a",{parentName:"p",href:"#caches"},"at the end of this session"),"\nThey are the fastest form of memory available and are implemented ",(0,i.yg)("strong",{parentName:"p"},"inside the CPU"),".\nWe can access data in registers in less than 1 ns (nanoseconds), as opposed to a few dozen ns when fetching data from the RAM."),(0,i.yg)("p",null,"Then why not make more registers and only use them instead of RAM?\nRegisters are fast because they are few in number.\nThis allows them to be efficiently wired to the CPU's Arithmetic and Logic Unit (ALU), which is responsible for executing basic operations, such as addition, subtraction, bitwise and, or, shifts etc.\nThe more registers, the more complex and the less efficient the logic."),(0,i.yg)("h3",{id:"registers-in-an-x64-cpu"},"Registers in an X64 CPU"),(0,i.yg)("p",null,"Registers are like variables with fixed names embedded in the CPU.\nThey can be assigned values that can be modified via instructions.\nThere are several types of registers inside a CPU.\nAll of them can be assigned data and that data can be modified using the assembly-level operations described ",(0,i.yg)("a",{parentName:"p",href:"#assembly-instructions"},"further in this session"),"."),(0,i.yg)("p",null,"All registers are ",(0,i.yg)("strong",{parentName:"p"},"64-bits")," wide.\nSo they each can store up to 8 bytes of data."),(0,i.yg)("h4",{id:"rip"},(0,i.yg)("inlineCode",{parentName:"h4"},"rip")),(0,i.yg)("p",null,"We'll start with a very special and illusive one: the ",(0,i.yg)("strong",{parentName:"p"},"instruction pointer")," - ",(0,i.yg)("inlineCode",{parentName:"p"},"rip"),".\nIn ",(0,i.yg)("a",{parentName:"p",href:"../binary-analysis/"},"the previous session"),', you learned that the code of any process is also in its memory.\nIn order to read and execute it, the CPU must "follow" it just like children follow text with their fingers.\nThe CPU does this using ',(0,i.yg)("inlineCode",{parentName:"p"},"rip"),".\nThis register stores te ",(0,i.yg)("strong",{parentName:"p"},"address of the currently executed instruction"),".\nWe will never use this instruction per-se in instructions, but you will see and make use of it in GDB."),(0,i.yg)("h4",{id:"general-purpose-registers"},"General Purpose Registers"),(0,i.yg)("p",null,"Then there are ",(0,i.yg)("strong",{parentName:"p"},"general purpose registers"),".\nAs their name implies, they are used to store ",(0,i.yg)("em",{parentName:"p"},"anything"),": addresses, user input, function parameters, data read from files or from the web etc.\nSome of them also have some special functions, especially regarding function calls:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"rax"),": accumulator register"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"rbx"),": base register"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"rcx"),": counter register; used with the ",(0,i.yg)("a",{parentName:"li",href:"#loops"},(0,i.yg)("inlineCode",{parentName:"a"},"loop"))," instruction"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"rdx"),": data register"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"rdi"),": destination register"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Rsi"),": source register"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"r8"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"r9")," ... ",(0,i.yg)("inlineCode",{parentName:"li"},"r15"),": regular registers")),(0,i.yg)("p",null,"Do not learn them by heart.\nAnd also do not bother with their extra meanings.\nWe will make use of those only when specified.\nOtherwise, treat them as simple variables."),(0,i.yg)("h4",{id:"smaller-registers"},"Smaller Registers"),(0,i.yg)("p",null,"Sometimes you only need to access 32 or 16 or 8 bits out of a 64-bit register.\nThis is possible by slightly changing the name of the register like so:"),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:"center"},"64 bits"),(0,i.yg)("th",{parentName:"tr",align:"center"},"Lowe 32 bits"),(0,i.yg)("th",{parentName:"tr",align:"center"},"Lower 16 bits"),(0,i.yg)("th",{parentName:"tr",align:"center"},"High 8 bits"),(0,i.yg)("th",{parentName:"tr",align:"center"},"Low 8 bits"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"rax")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"eax")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"ax")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"ah")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"al"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"rdi")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"edi")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"di")),(0,i.yg)("td",{parentName:"tr",align:"center"},"unaccessible"),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dil"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"r8")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"r8d")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"r8w")),(0,i.yg)("td",{parentName:"tr",align:"center"},"unaccessible"),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"r8l"))))),(0,i.yg)("p",null,"The bits contained in each of the above subdivisions are shown in the image below.\nIt is similar for ",(0,i.yg)("inlineCode",{parentName:"p"},"rdi")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"r8"),", it's just the names that differ."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"rax Subdivisions",src:t(2466).A})),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"rbx"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"rcx")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"rdx")," have the same subdivisions as ",(0,i.yg)("inlineCode",{parentName:"p"},"rax"),".\n",(0,i.yg)("inlineCode",{parentName:"p"},"rsi")," has the same subdivision as ",(0,i.yg)("inlineCode",{parentName:"p"},"rdi"),": ",(0,i.yg)("inlineCode",{parentName:"p"},"esi"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"si")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"sil"),".\nIt doesn't make sense to access 4 bytes of an address.\nThe lower 2 bytes can be accessed due to historical reasons.\nIn the 70s, when the first CPU of this family (8086) was launched, it only supported 2-byte addresses.\nAll registers ",(0,i.yg)("inlineCode",{parentName:"p"},"r9")," to ",(0,i.yg)("inlineCode",{parentName:"p"},"r15")," have the same subdivisions as ",(0,i.yg)("inlineCode",{parentName:"p"},"r8"),"."),(0,i.yg)("h2",{id:"assembly-instructions"},"Assembly Instructions"),(0,i.yg)("p",null,"We've now learned what assembly is theoretically and what registers are, but how do we use them?\nEach CPU exposes an ",(0,i.yg)("strong",{parentName:"p"},"ISA (Instruction Set Architecture)"),": a set of instructions with which to modify and interact with its registers and with the RAM.\nThere are over 1000 instructions in the x64 ISA.\nThere are even instructions for efficiently encrypting data.\nFind out more about them by enrolling in the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/security-summer-school/hardware-sec/"},"Hardware Assisted Security track"),"."),(0,i.yg)("p",null,"Before we dive into the instructions themselves, it's useful to first look at their generic syntax:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"instruction_name destination, source\n")),(0,i.yg)("p",null,"Most Assembly instructions have 2 operands: a source and a destination.\nFor some operations, such as arithmetic, the destination is also an operand.\nThe result of each instruction is always stored in the destination."),(0,i.yg)("p",null,"Below we'll list some fundamental instructions.\nWe will be using the Intel Assembly syntax."),(0,i.yg)("h3",{id:"mov"},(0,i.yg)("inlineCode",{parentName:"h3"},"mov")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"mov")," is the most basic instruction in Assembly.\nIt ",(0,i.yg)("em",{parentName:"p"},"copies")," (or ",(0,i.yg)("em",{parentName:"p"},"moves"),") data from the source to the destination.\nAlso note that comments in Assembly are preceded by ",(0,i.yg)("inlineCode",{parentName:"p"},";")," and that the language is case-insensitive."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},'mov eax, 3              ; eax = 3\n\nmov rbx, "SSS Rulz"     ; place the string "SSS Rulz" in `rbx`\n; This places each byte of the string "SSS Rulz" in rbx.\n\nmov r8b, bh             ; r8b = bh\n; The sizes of the operands must be equal (1 byte each in this case).\n')),(0,i.yg)("h3",{id:"data-manipulation"},"Data Manipulation"),(0,i.yg)("p",null,"Now that we've learnt how to place data in registers we need to learn how to do math with it.\nAs you've seen so far, Assembly instructions are really simple.\nBelow is a table with the most common and useful arithmetic instructions.\nTry to figure out what each example does.\nUse the fact that the general anatomy of an instruction is usually ",(0,i.yg)("inlineCode",{parentName:"p"},"instruction destination, source"),".\nThe result is always stored in the ",(0,i.yg)("inlineCode",{parentName:"p"},"destination")),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:"center"},"Instruction"),(0,i.yg)("th",{parentName:"tr",align:"center"},"Description"),(0,i.yg)("th",{parentName:"tr",align:"center"},"Examples"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"add <dest>, <src>")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dest += src")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"add rbx, 5"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"add r11, 0x99"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"sub <dest>, <src>")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dest -= src")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"sub ecx, 'a'"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"sub r9, r8"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"shl <dest>, <bits>")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dest <<= bits")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"shl rax, 3"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"shl rdi, cl"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"shr <dest>, <bits>")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dest >>= bits")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"shr r15, 5"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"shr rsi, cl"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"and <dest> <src>")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dest &= src")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"and al, ah"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"and bx, 13"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"or <dest> <src>")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dest \\|= src")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"or r10b, cl"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"or r14, 0x2000"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"xor <dest> <src>")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dest ^= src")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"xor ebx, edx"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"xor rcx, 1"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"inc <dest>")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dest++")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"inc rsi"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dec <dest>")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dest--")),(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"dec r10w"))))),(0,i.yg)("h3",{id:"control-flow"},"Control Flow"),(0,i.yg)("p",null,"Now we know how to do maths and move bits around.\nThis is all good, but we still can't write full programs.\nWe need a mechanism similar to ",(0,i.yg)("inlineCode",{parentName:"p"},"if"),"s from Python and also loops in order to make the code run based on conditions."),(0,i.yg)("h4",{id:"jmp"},(0,i.yg)("inlineCode",{parentName:"h4"},"jmp")),(0,i.yg)("p",null,"The simplest instruction for control flow is the ",(0,i.yg)("inlineCode",{parentName:"p"},"jmp")," instruction.\nIt simply loads an address into the ",(0,i.yg)("inlineCode",{parentName:"p"},"rip")," register.\nBut when Assembly code is generated or written either by the compiler or by us, instructions don't have addresses yet.\nThese addresses are assigned during the ",(0,i.yg)("strong",{parentName:"p"},"linking")," or ",(0,i.yg)("strong",{parentName:"p"},"loading")," phase, as you know from the ",(0,i.yg)("a",{parentName:"p",href:"../application-lifetime/"},"Application Lifetime session"),"."),(0,i.yg)("p",null,"For this reason, we use ",(0,i.yg)("strong",{parentName:"p"},"labels")," as some sort of anchors.\nWe ",(0,i.yg)("inlineCode",{parentName:"p"},"jmp")," to them and then the assembler will replace them with relative addresses which are then replaced with full addresses during linking.\nThe way in which ",(0,i.yg)("inlineCode",{parentName:"p"},"jmp")," and labels function is very simple.\nRemember that in the absence of ",(0,i.yg)("inlineCode",{parentName:"p"},"jmp"),"s, Assembly code is executed linearly just like a script."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"    jmp skip_next_section\n\n    ; Whatever code is here is never executed.\n\nskip_next_section:\n    ; Only the code below this label is executed.\n")),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"Warning"),"\nDo not confuse labels with functions.\nA label does not stop the execution of code when it's reached.\nThey are simply ignored by anything except for ",(0,i.yg)("inlineCode",{parentName:"p"},"jmp"),".")),(0,i.yg)("p",null,"For example, kin the the following code, both instructions are executed in the absence of ",(0,i.yg)("inlineCode",{parentName:"p"},"jmp"),"s:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"    mov rax, 2\nsome_label:\n    mov rbx, 3\n    ; rax = 2; rbx = 3\n")),(0,i.yg)("h4",{id:"eflags"},(0,i.yg)("inlineCode",{parentName:"h4"},"eflags")),(0,i.yg)("p",null,"Each instruction (except for ",(0,i.yg)("inlineCode",{parentName:"p"},"mov"),") changes the ",(0,i.yg)("strong",{parentName:"p"},"inner state of the CPU"),".\nIn other words, several aspects regarding the result of the instruction are stored in a special register that we cannot access directly, called ",(0,i.yg)("inlineCode",{parentName:"p"},"eflags"),".\nThere are ",(0,i.yg)("a",{parentName:"p",href:"https://stackoverflow.com/questions/1406783/how-to-read-and-write-x86-flags-registers-directly"},"instructions")," that can set or clear some flags in ",(0,i.yg)("inlineCode",{parentName:"p"},"eflags"),", but we cannot write something like ",(0,i.yg)("inlineCode",{parentName:"p"},"mov eflags, 2"),"."),(0,i.yg)("p",null,"As its name implies, each bit in ",(0,i.yg)("inlineCode",{parentName:"p"},"eflags")," is a flag that is activated (i.e. set to 1) if a certain condition is true about the result of the last executed instruction.\nWe won't be using these flags per se with one exception: ",(0,i.yg)("inlineCode",{parentName:"p"},"ZF")," - the ",(0,i.yg)("strong",{parentName:"p"},"zero flag"),".\nWhen active, it means that the result of the last instruction was... 0, duh!\nThis is useful for testing if numbers are equal for example.\nWe'll talk about this in the next section."),(0,i.yg)("h4",{id:"conditional-jumps"},"Conditional jumps"),(0,i.yg)("p",null,"Now we know that there is an internal state of the CPU which is modified by each instruction, except for ",(0,i.yg)("inlineCode",{parentName:"p"},"mov"),".\nWe still need a way to leverage this state.\nWe can do this via ",(0,i.yg)("strong",{parentName:"p"},"conditional jumps"),"."),(0,i.yg)("p",null,"They are like ",(0,i.yg)("inlineCode",{parentName:"p"},"jmp")," instructions, but the jump is made only when certain conditions are met.\nOtherwise, code execution continues from the next instruction.\nThe general syntax of a conditional jump is"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"j[n]<cond> label\n")),(0,i.yg)("p",null,"where the letter ",(0,i.yg)("inlineCode",{parentName:"p"},"n")," is optional and means the jump will be made if the condition is ",(0,i.yg)("strong",{parentName:"p"},"not")," met."),(0,i.yg)("h5",{id:"cmp-and-test"},(0,i.yg)("inlineCode",{parentName:"h5"},"cmp")," and ",(0,i.yg)("inlineCode",{parentName:"h5"},"test")),(0,i.yg)("p",null,"We can use the regular arithmetic instructions that we've learned so far to modify ",(0,i.yg)("inlineCode",{parentName:"p"},"eflags"),".\nBut this has the drawback of also modifying our data.\nIt would be great if we had a means to modify ",(0,i.yg)("inlineCode",{parentName:"p"},"eflags")," without changing the data that we evaluate.\nWe can do this using ",(0,i.yg)("inlineCode",{parentName:"p"},"cmp")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"test"),"."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"cmp dest, src")," modifies ",(0,i.yg)("inlineCode",{parentName:"p"},"eflags")," as if you were ",(0,i.yg)("strong",{parentName:"p"},"subtracting")," ",(0,i.yg)("inlineCode",{parentName:"p"},"src")," from ",(0,i.yg)("inlineCode",{parentName:"p"},"dst"),", but without modifying ",(0,i.yg)("inlineCode",{parentName:"p"},"dst"),".\nThis is great for testing if 2 things are equal, or for testing which is greater or lower."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"test dest, src")," is similar to ",(0,i.yg)("inlineCode",{parentName:"p"},"cmp"),", but modifies ",(0,i.yg)("inlineCode",{parentName:"p"},"eflags")," according to the ",(0,i.yg)("inlineCode",{parentName:"p"},"and")," instruction.\nThis comes in handy when we want to check if a register is 0."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"test rax, rax\njz rax_is_zero\n")),(0,i.yg)("p",null,"is equivalent to"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"cmp rax, 0\njz rax_is_zero\n")),(0,i.yg)("p",null,"Now let's have a look at some conditional jumps:"),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:"center"},"Conditional jump"),(0,i.yg)("th",{parentName:"tr",align:"center"},"Meaning"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"jz")," / ",(0,i.yg)("inlineCode",{parentName:"td"},"je")),(0,i.yg)("td",{parentName:"tr",align:"center"},"Jump if the Zero Flag is active")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"jnz")," / ",(0,i.yg)("inlineCode",{parentName:"td"},"jne")),(0,i.yg)("td",{parentName:"tr",align:"center"},"Jump if the Zero Flag is not active")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"cmp rax, rbx"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"j[n]g")),(0,i.yg)("td",{parentName:"tr",align:"center"},"Jump if ",(0,i.yg)("inlineCode",{parentName:"td"},"rax")," is (not) greater (signed) than ",(0,i.yg)("inlineCode",{parentName:"td"},"rbx"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"cmp rax, rbx"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"j[n]a")),(0,i.yg)("td",{parentName:"tr",align:"center"},"Jump if ",(0,i.yg)("inlineCode",{parentName:"td"},"rax")," is (not) greater (unsigned) than ",(0,i.yg)("inlineCode",{parentName:"td"},"rbx"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"cmp rax, rbx"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"j[n]ge")),(0,i.yg)("td",{parentName:"tr",align:"center"},"Jump if ",(0,i.yg)("inlineCode",{parentName:"td"},"rax")," is (not) greater (signed) or equal than ",(0,i.yg)("inlineCode",{parentName:"td"},"rbx"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"cmp rax, rbx"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"j[n]ae")),(0,i.yg)("td",{parentName:"tr",align:"center"},"Jump if ",(0,i.yg)("inlineCode",{parentName:"td"},"rax")," is (not) greater (unsigned) or equal than ",(0,i.yg)("inlineCode",{parentName:"td"},"rbx"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"cmp rax, rbx"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"j[n]l")),(0,i.yg)("td",{parentName:"tr",align:"center"},"Jump if ",(0,i.yg)("inlineCode",{parentName:"td"},"rax")," is (not) lower (signed) than ",(0,i.yg)("inlineCode",{parentName:"td"},"rbx"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"cmp rax, rbx"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"j[n]b")),(0,i.yg)("td",{parentName:"tr",align:"center"},"Jump if ",(0,i.yg)("inlineCode",{parentName:"td"},"rax")," is (not) lower (unsigned) than ",(0,i.yg)("inlineCode",{parentName:"td"},"rbx"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"cmp rax, rbx"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"j[n]le")),(0,i.yg)("td",{parentName:"tr",align:"center"},"Jump if ",(0,i.yg)("inlineCode",{parentName:"td"},"rax")," is (not) lower (signed) or equal than ",(0,i.yg)("inlineCode",{parentName:"td"},"rbx"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:"center"},(0,i.yg)("inlineCode",{parentName:"td"},"cmp rax, rbx"),(0,i.yg)("br",null),(0,i.yg)("inlineCode",{parentName:"td"},"j[n]be")),(0,i.yg)("td",{parentName:"tr",align:"center"},"Jump if ",(0,i.yg)("inlineCode",{parentName:"td"},"rax")," is (not) lower (unsigned) or equal than ",(0,i.yg)("inlineCode",{parentName:"td"},"rbx"))))),(0,i.yg)("h4",{id:"loops"},"Loops"),(0,i.yg)("p",null,"We can create loops simply by combining labels and conditional jumps.\nFor example, ",(0,i.yg)("inlineCode",{parentName:"p"},"for i in range(0, 10)")," from Python is equivalent to:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"    xor rcx, rcx    ; i = rcx; same as mov rcx, 0\nfor_loop:\n    cmp rcx, 10\n    je done_loop    ; verify i < 10\n\n    ; The body of the for loop.\n\n    inc rcx         ; rcx++\n    jmp for_loop    ; re-evaluate the condition\n\ndone_loop:\n")),(0,i.yg)("p",null,"Or alternatively, we can verify ",(0,i.yg)("inlineCode",{parentName:"p"},"rcx < 10")," at the end of the loop:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"    xor rcx, rcx\nfor_loop:\n    ; The body of the for loop.\n\n    inc rcx         ; rcx++\n    cmp rcx, 10\n    jb for_loop    ; verify i < 10\n\n    ; The code here is executed only after the loop ends.\n")),(0,i.yg)("h2",{id:"dereferencing-addresses"},"Dereferencing Addresses"),(0,i.yg)("p",null,"Up to this point we know how to operate with data and can write complex programs using conditional jumps.\nBut we know that data is stored mostly in the RAM.\nHow do we fetch it from there to our registers?"),(0,i.yg)("p",null,"Imagine the RAM is one giant array.\nEach byte is a cell in this array.\nTherefore, each byte is found at a given ",(0,i.yg)("strong",{parentName:"p"},"index")," in this array.\nIndices start at 0, so the first byte is found at index 0, the third 3 at index 2 and so on.\nThese indices are also called ",(0,i.yg)("strong",{parentName:"p"},"memory addresses"),", or simply ",(0,i.yg)("strong",{parentName:"p"},"addresses"),"."),(0,i.yg)("p",null,"In order to load data from the RAM into our registers or vice-versa, we need to specify the CPU which RAM address to access.\nThis is called ",(0,i.yg)("strong",{parentName:"p"},"dereferencing that address"),".\nSyntactically, this is very easy and is done by wrapping the address in ",(0,i.yg)("inlineCode",{parentName:"p"},"[]"),".\nThe address can be either a raw number, or a register, or an expression:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov rax, [0xdeadbeef]   ; load 8 bytes from the address 0xdeadbeef into rax\nmov bx, [0xdeadbeef]    ; load 2 bytes from the address 0xdeadbeef into bx\nmov [0xdeadbeef], ecx   ; store 4 bytes from ecx at the address 0xdeadbeef\n")),(0,i.yg)("p",null,"Notice that the number of bytes that are transferred between the RAM and registers is given by the size of the register.\nBut what happens when we don't use a register?\nThe code below is incorrect because it is impossible to tell how many bytes to use to write 0x69.\nWe could write it using one byte of course, but what if we wanted to write it on 4 bytes and store ",(0,i.yg)("inlineCode",{parentName:"p"},"[ 0x00 | 0x00 | 0x00 | 0x69 ]"),"?\nTo eliminate such ambiguities, we must specify the number of bytes that we want to write to the RAM:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov [0xdeadbeef], byte 0x2      ; writes 1 byte\nmov [0xdeadbeef], word 0x2      ; writes 2 bytes: 0x00 and 0x02\nmov [0xdeadbeef], dword 0x2     ; writes 4 bytes\nmov [0xdeadbeef], qword 0x2     ; writes 8 bytes\n")),(0,i.yg)("p",null,"Instead of a hardcoded value, we can express addresses as complex expressions which the CPU computes for us.\nIn the snippet below, the CPU computes the address given by ",(0,i.yg)("inlineCode",{parentName:"p"},"rdi + rcx * 4")," and then writes the contents of ",(0,i.yg)("inlineCode",{parentName:"p"},"edx")," there."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov [rdi + rcx * 4], edx\n")),(0,i.yg)("p",null,"This is equivalent to ",(0,i.yg)("inlineCode",{parentName:"p"},"v[i] = something")," where ",(0,i.yg)("inlineCode",{parentName:"p"},"v")," is an array of 4-byte values (hence ",(0,i.yg)("inlineCode",{parentName:"p"},"rcx * 4"),"):"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"rdi")," = starting address of ",(0,i.yg)("inlineCode",{parentName:"li"},"v")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"rcx")," = ",(0,i.yg)("inlineCode",{parentName:"li"},"i")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"edx")," = ",(0,i.yg)("inlineCode",{parentName:"li"},"something"))),(0,i.yg)("p",null,"Therefore, whenever you see ",(0,i.yg)("inlineCode",{parentName:"p"},"[...]")," in Assembly, what between the square brackets is being dereferenced ",(0,i.yg)("a",{parentName:"p",href:"#lea"},(0,i.yg)("strong",{parentName:"a"},"with one exception")),"."),(0,i.yg)("h3",{id:"endianness"},"Endianness"),(0,i.yg)("p",null,"This is all nice, but how does all this look like in the memory?\nThe order in which the bytes are stored in the RAM is called ",(0,i.yg)("strong",{parentName:"p"},"endianness"),".\nMost CPUs store bytes ",(0,i.yg)("strong",{parentName:"p"},"in reverse order"),", or ",(0,i.yg)("strong",{parentName:"p"},"little endian")," order, because the least significant byte is the first.\nWhen data is fetched back from the ram, the order is reversed:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov [0x100], dword 0x12345678       ; the RAM at 0x100: [ 0x78 | 0x56 | 0x34 | 0x12 ]\nmov ax, [0x100]     ; ax = 0x5678\nmov bx, [101]       ; bx = 0x3456\n")),(0,i.yg)("p",null,"However, endianness does not apply to strings.\nThe code below writes the string ",(0,i.yg)("inlineCode",{parentName:"p"},"SSS Rulz")," at the address 0x100.\nNotice we don't have to write it in reverse order like ",(0,i.yg)("inlineCode",{parentName:"p"},"zluR SSS"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},'mov rax, "SSS Rulz"\nmov [0x100], rax\n; We need to use a register because mov cannot take both an address and a 64-bit immediate as operands.\n; https://www.felixcloutier.com/x86/mov\n')),(0,i.yg)("h2",{id:"reading-assembly"},"Reading Assembly"),(0,i.yg)("h3",{id:"objdump"},(0,i.yg)("inlineCode",{parentName:"h3"},"objdump")),(0,i.yg)("p",null,"Starting from an executable file, we can read its Assembly code by ",(0,i.yg)("strong",{parentName:"p"},"disassembling")," it.\nThe standard tool for doing this is ",(0,i.yg)("inlineCode",{parentName:"p"},"objdump"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"root@kali:~$ objdump -M intel -d <binary> | less\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"-M intel")," for Intel syntax.\nThe default syntax is AT&T."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"-d"),' stands for "disassembly".'),(0,i.yg)("li",{parentName:"ul"},"pipe the output to ",(0,i.yg)("inlineCode",{parentName:"li"},"less")," so you can navigate the Assembly code more easily.")),(0,i.yg)("p",null,"Notice that every line contains an address, an opcode and an instruction.\nThe opcode is simply the binary representation of that instruction."),(0,i.yg)("p",null,"Alternatively, you can use GDB and Ghidra that you learned about ",(0,i.yg)("a",{parentName:"p",href:"../binary-analysis/"},"in the previous session"),"."),(0,i.yg)("h3",{id:"gdb"},"GDB"),(0,i.yg)("p",null,"The undisputed king of Assembly is by far the ",(0,i.yg)("strong",{parentName:"p"},"GNU DeBugger (GDB)"),".\nIt's just what its name says it is, but its beauty is in its versatility.\nGDB is a command-line debugger that allows us to print registers, variables, dump memory from any address, step through the code, go back through the call stack and much more.\nToday we will only get a glimpse of its power."),(0,i.yg)("p",null,"We are using the ",(0,i.yg)("inlineCode",{parentName:"p"},"pwndbg")," extension for GDB as it allows us to view the assembly code, stack (you'll learn about it in the ",(0,i.yg)("a",{parentName:"p",href:"../taming-the-stack/"},"next session"),") and registers.\nFollow the instructions ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/pwndbg/pwndbg#how"},"here")," to install it if you haven't done so already."),(0,i.yg)("p",null,"GDB can run Assembly instructions one by one and stops after each instruction.\nThe current instruction is also clearly displayed.\nBelow is a reduced list of useful GDB commands to get you going.\nUse it as a cheatsheet when you get stuck:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"start")," = start running the program from ",(0,i.yg)("inlineCode",{parentName:"p"},"main"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"list")," = decompile and display C code\nOnly works for executables compiled with ",(0,i.yg)("inlineCode",{parentName:"p"},"-g"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"pdis")," = disassemble and display instructions with nice syntax highlighting")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"next")," / ",(0,i.yg)("inlineCode",{parentName:"p"},"n")," = run the current C code\nIf it is a function call, it is executed without stepping into the function.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"nexti")," / ",(0,i.yg)("inlineCode",{parentName:"p"},"ni")," = run the current Assembly instruction")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"step")," / ",(0,i.yg)("inlineCode",{parentName:"p"},"s")," = if the debugger has reached a function call, step into it.\nOtherwise, it behaves like ",(0,i.yg)("inlineCode",{parentName:"p"},"next")," / ",(0,i.yg)("inlineCode",{parentName:"p"},"n"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"stepi")," / ",(0,i.yg)("inlineCode",{parentName:"p"},"si")," = step into function (used for the ",(0,i.yg)("inlineCode",{parentName:"p"},"call")," instruction in Assembly)")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"break")," / ",(0,i.yg)("inlineCode",{parentName:"p"},"b <n>")," = place a breakpoint at line ",(0,i.yg)("inlineCode",{parentName:"p"},"n"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"break")," / ",(0,i.yg)("inlineCode",{parentName:"p"},"b *<address>")," = place breakpoint at address")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"continue")," / ",(0,i.yg)("inlineCode",{parentName:"p"},"c")," = run code until next breakpoint")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"info registers <name>")," = display the values in all registers.\nIf a name is specified, only the value in that register is displayed")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"p <variable>")," / ",(0,i.yg)("inlineCode",{parentName:"p"},"<name>")," = print the variable / number; similar to ",(0,i.yg)("inlineCode",{parentName:"p"},"printf")))),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'p/d = printf("%d")\np/c = printf("%c")\np/x = printf(\u201c%x\u201d)\np/u = printf(\u201c%u\u201d)\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"x <address>")," = print data at the address (dereference it).\nBy default, the output is represented in hex"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"x/<n><d><f> <address>")," -> print ",(0,i.yg)("inlineCode",{parentName:"li"},"n")," memory areas of size ",(0,i.yg)("inlineCode",{parentName:"li"},"d")," with format ",(0,i.yg)("inlineCode",{parentName:"li"},"f"),":")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"n = any number; default = 1\nd = b (byte - default) / h (half-word = short) / w (word = int) \nf = (like p): x (hex - default)  / c (char) / d (int, decimal) / u (unsigned)  / s (string)\n")),(0,i.yg)("p",null,"Examples:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"x/20wx = 20 hex words (ints)\nx/10hd = 10 decimal half-words (shorts)\nx/10c = 10 ASCII characters\nx/10b = 10 hex bytes (because x is the default)\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"set $<register> <value>")," = sets the register to that value")),(0,i.yg)("h2",{id:"summary"},"Summary"),(0,i.yg)("p",null,"The key takeaways from this session are:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Assembly is a human-readable representation of instructions executed by the CPU"),(0,i.yg)("li",{parentName:"ul"},"It allows us to access CPU registers directly"),(0,i.yg)("li",{parentName:"ul"},"It uses a fixed set of instructions called ISA"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Memory")," is the RAM, ",(0,i.yg)("strong",{parentName:"li"},"storage")," is the disk"),(0,i.yg)("li",{parentName:"ul"},"Data is stored in memory using the little endian representation"),(0,i.yg)("li",{parentName:"ul"},"You can disassemble a program with ",(0,i.yg)("inlineCode",{parentName:"li"},"objdump")," like so:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"root@kali:~$ objdump -M intel -d <program> |less\n")),(0,i.yg)("h2",{id:"activities"},"Activities"),(0,i.yg)("h3",{id:"in-plain-assembly"},"In Plain Assembly"),(0,i.yg)("p",null,"The flag is almost right there in your face."),(0,i.yg)("h3",{id:"gotta-link-em-all"},"Gotta Link Em All"),(0,i.yg)("p",null,"I wonder what hides in all those object files..."),(0,i.yg)("h3",{id:"jump-maze"},"Jump Maze"),(0,i.yg)("p",null,"Theseus has nothing on you!\nNavigate the maze and get the flag."),(0,i.yg)("h3",{id:"crypto"},"Crypto"),(0,i.yg)("p",null,"Is it really about crypto?"),(0,i.yg)("h3",{id:"call-me-little-sunshine"},"Call Me Little Sunshine"),(0,i.yg)("p",null,"Do what the binary asks you to do.\nWhat, it doesn't work?"),(0,i.yg)("h2",{id:"further-reading"},"Further Reading"),(0,i.yg)("h3",{id:"the-whole-isa"},"The Whole ISA"),(0,i.yg)("p",null,"If you want to search for an instruction, use ",(0,i.yg)("a",{parentName:"p",href:"https://www.felixcloutier.com/x86/"},"this")," website.\nEach instruction has its own table with all possible operands and what they do.\nNote that ",(0,i.yg)("inlineCode",{parentName:"p"},"imm8"),' means "8-bit immediate" (an 8-byte regular number), ',(0,i.yg)("inlineCode",{parentName:"p"},"imm64")," means a 64-bit immediate and so on.\nSimilarly, ",(0,i.yg)("inlineCode",{parentName:"p"},"reg32")," means a 32-bit register and ",(0,i.yg)("inlineCode",{parentName:"p"},"m16")," for example means a 16-bit (2-byte) memory area.\nYou'll see ",(0,i.yg)("inlineCode",{parentName:"p"},"reg"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"imm")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"m")," combined with ",(0,i.yg)("inlineCode",{parentName:"p"},"8"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"16"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"32")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"64")," depending on what each instruction does."),(0,i.yg)("h3",{id:"caches"},"Caches"),(0,i.yg)("p",null,"Many programs access the same addresses repeatedly over a short period of time.\nTake a short 1000-step loop.\nIt uses the same code 1000 times.\nIt would be inefficient for the CPU to read the instructions directly from the RAM 1000 times.\nFor this reason, there is an intermediary level of memory between the RAM and the registers, called ",(0,i.yg)("strong",{parentName:"p"},"the cache"),"."),(0,i.yg)("p",null,"As their name implies, caches store the contents of some memory addresses that are frequently requested by the CPU.\nWe say ",(0,i.yg)("em",{parentName:"p"},"caches"),", in plural because they are laid out hierarchically, each lower level being faster and smaller than the ones below.\nUsually, CPUs have 3 levels of cache memory.\nYou can query their sizes with the ",(0,i.yg)("inlineCode",{parentName:"p"},"lscpu")," command:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"root@kali:~$ lscpu\n[...]\nL1d cache:                       128 KiB\nL1i cache:                       128 KiB\nL2 cache:                        1 MiB\nL3 cache:                        6 MiB\n[...]\n")),(0,i.yg)("p",null,"Notice the L1 (level 1) cache is split between a data cache (",(0,i.yg)("inlineCode",{parentName:"p"},"L1d"),") and an instruction cache ",(0,i.yg)("inlineCode",{parentName:"p"},"L1i"),".\nThe other caches do not store data and instructions separately."),(0,i.yg)("h3",{id:"assembly-syntaxes"},"Assembly Syntaxes"),(0,i.yg)("p",null,"This session we've used the Intel syntax for writing and displaying Assembly.\nWe did so because it's more straightforward than its alternative: the AT&T syntax.\nYou can find the differences on ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/X86_assembly_language#Syntax"},"Wikipedia"),"."),(0,i.yg)("h3",{id:"lea"},(0,i.yg)("inlineCode",{parentName:"h3"},"lea")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"lea"),' stands for "Load Effective Address".\nIts syntax is:'),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"lea dest, [address]\n")),(0,i.yg)("p",null,"It loads ",(0,i.yg)("inlineCode",{parentName:"p"},"address")," into the ",(0,i.yg)("inlineCode",{parentName:"p"},"dest")," register (it can only be a register).\nWhat's interesting about it is that it also uses the ",(0,i.yg)("inlineCode",{parentName:"p"},"[...]")," syntax, but ",(0,i.yg)("strong",{parentName:"p"},"does not dereference the address"),".\nIn the snippet below, ",(0,i.yg)("inlineCode",{parentName:"p"},"0xdeadbeef")," is simply copied to ",(0,i.yg)("inlineCode",{parentName:"p"},"rax"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"lea rax, [0xdeadbeef]\n")),(0,i.yg)("p",null,"Its true power comes from the fact that it can also compute an address.\nFor example, the code below will first compute the address given by ",(0,i.yg)("inlineCode",{parentName:"p"},"rdi + rcx * 8 + 7")," and then write this address into ",(0,i.yg)("inlineCode",{parentName:"p"},"rax"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"lea rax, [rdi + rcx * 8 + 7]\n")))}m.isMDXComponent=!0},6486:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/memory-hierarchy-4d4374f26fd02d44a54142b710c3c169.png"},2466:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/rax-subdivisions-30bbbba21a1b4eda4afd00d37e4ed801.svg"}}]);